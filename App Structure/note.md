### Unziping the apk

command: 
- unzip <File\> -d <Folder\>

**DEX and ODEX in Android (Short Note)**

**DEX (Dalvik Executable):**
DEX is the compiled bytecode format used by Android. Java/Kotlin source code is first compiled into `.class` files, then converted into a single or multiple `.dex` files using the D8/R8 tool. These `.dex` files are optimized for low memory usage and are executed by the Android Runtime (ART). Every APK contains DEX files.

**ODEX (Optimized Dalvik Executable):**
ODEX is an optimized version of DEX, usually generated by the system for **pre-installed (system) apps**. In ODEX, some parts of the app are pre-compiled and stored outside the APK (in `/system/framework` or `/system/app`). This helps the device boot faster and reduces runtime optimization during first launch.

**Key Differences:**

* DEX → Inside APK, used by all apps
* ODEX → Outside APK, mainly for system apps
* DEX → Compiled at install/run time
* ODEX → Pre-optimized for faster boot and performance

**Modern Android Note:**
From Android 5.0 (ART) onward, the system mainly uses **AOT (Ahead-of-Time)** and **JIT compilation**, so traditional ODEX usage is less visible, but the concept of pre-optimization still exists.

```
ayush@ayush-83eq:~/Desktop/ANDROID_APP_HACKING/App Structure/spacepeng$ file classes.dex 
classes.dex: Dalvik dex file version 035
```

### GHex (Short Note)

**GHex is a hexadecimal editor used mainly on Linux systems.** It allows users to view, edit, and analyze files at the byte (hex) level, which is useful for low-level debugging, reverse engineering, and file inspection.

- `sudo apt-get install ghex`
- `ghex classes.dex `

**dexdump (Short Note)**

**dexdump** is a **command-line tool** provided in the **Android SDK** that is used to **analyze DEX (Dalvik Executable) files**. It prints the internal structure of a `.dex` file in a **human-readable format**.

**Key Points:**

* Displays **classes, methods, fields, strings, and bytecode**
* Used for **reverse engineering and debugging**
* Helps understand how an APK is structured internally
* Works on **classes.dex** files extracted from APKs
* Output can be shown in **brief or detailed** form

**Example Use:**

```bash
dexdump classes.dex
```

**Common Uses:**

* Studying compiled Android apps
* Verifying DEX content after build or modification
* Analyzing suspicious or malware APKs

**Note:**
`dexdump` **does not modify** files—it is strictly an **inspection tool**.


**ADB & APK Tools – Short Notes**

**1. `adb shell`**
Used to open a **remote Linux shell** on a connected Android device or emulator. It allows direct interaction with the Android system.

* Used for debugging, file access, and system commands
* Example: `adb shell ls /system/app`

**2. `pm list packages`**
A **Package Manager (pm)** command used inside `adb shell` to list installed apps.

* Lists all installed package names
* Options:

  * `pm list packages -s` → system apps
  * `pm list packages -3` → user apps

**3. `pm path <package_name>`**
Displays the **APK file path** of a specific installed application.

* Helps locate where the APK is stored
* Example: `pm path com.android.settings`

**4. `adb pull`**
Used to **copy files from Android device to PC**.

* Commonly used to extract APKs or logs
* Example:

  ```bash
  adb pull /data/app/com.example.apk
  ```

**5. APKTool**
A **reverse-engineering tool** for Android APKs.

* Decodes resources (`XML`, `Manifest`) into readable form
* Rebuilds APK after modification
* Commonly used in **app modding and security analysis**

**Typical Workflow Example:**
`adb shell` → `pm list packages` → `pm path` → `adb pull` → analyze with **APKTool**


## Decompiling - HandsOn

- **step 1** - download the apktool
- **step 2** - keep the jar file in a new known location
- **step 3** - create an aleas to make it run on terminal directly
- **step 4** - `apktool d base.apk` for decompiling

```bash
ayush@ayush-83eq:~/Desktop/ANDROID_APP_HACKING/App Structure/spacepeng_decompile$ apktool d base.apk 
I: Using Apktool 2.12.1 on base.apk with 8 threads
I: Baksmaling classes.dex...
I: Loading resource table...
I: Decoding file-resources...
I: Decoding values */* XMLs...
I: Loading resource table from file: /home/ayush/.local/share/apktool/framework/1.apk
I: Decoding AndroidManifest.xml with resources...
I: Copying original files...
I: Copying assets...
I: Copying lib...
I: Copying unknown files...

```

- **step 5** - Edit
- **step 6** - `apktool b base/` for building bask the apk

```bash
ayush@ayush-83eq:~/Desktop/ANDROID_APP_HACKING/App Structure/spacepeng_decompile$ apktool b base/
I: Using Apktool 2.12.1 on base.apk with 8 threads
I: Checking whether sources have changed...
I: Smaling smali folder into classes.dex...
I: Checking whether resources have changed...
I: Building resources with aapt2...
I: Building apk file...
I: Importing assets...
I: Importing lib...
I: Importing unknown files...
I: Built apk into: base/dist/base.apk
```

- **step 7** - You can find the apk in the `dist` folder in the `base` folder.

**Note** - You can't install in right now because the application is not signed yet.

**Short Note**

* **`/data/system/packages.xml`**\
  Stores **app UIDs** and the **permissions granted** to each installed application. It is maintained by the Package Manager and reflects the **current permission state** of apps.

* **`/etc/permissions/platform.xml`**\
  Defines **Android platform permissions**, their **protection levels** (normal, dangerous, signature, system) and maps them to **Linux groups**, determining what access each permission provides.

**In short:**

* `packages.xml` → *who (UID/app) has which permissions*
* `platform.xml` → *what those permissions mean and how protected they are*



---

### **`am` and `am start-activity` (Android Activity Manager)**

`am` (Activity Manager) is an Android Debug Bridge (ADB) shell command used to interact with Android system components such as activities, services, and broadcasts.

The command **`am start-activity`** (or simply `am start`) is used to launch an activity from the command line without using the app’s user interface. It is mainly used for testing, debugging, and security analysis of Android applications.

**Syntax:**

```
am start -n <package_name>/<activity_name>
```

**Example:**

```
am start -n com.example.app/.MainActivity
```

This command sends an explicit Intent to the specified activity and starts it if the activity is exported and exists in the application manifest.

**Uses:**

* Launches activities directly from terminal/ADB
* Helps in debugging and penetration testing
* Verifies whether an activity is accessible (exported)
* Useful for automation and app behavior analysis

**Common errors:**

* *Bad component name*: incorrect package or activity name
* *Permission Denial*: activity is not exported or requires permission

---

### **Intents in Android App Development (Short Note)**

**Intent** is a messaging object used to request an action from another app component. It allows communication between **activities, services, and broadcast receivers**.

**Types of Intents:**

1. **Explicit Intent** – Targets a specific component within the same app.
   Example: Opening another activity in the same app.
2. **Implicit Intent** – Does not name a specific component; Android chooses an app that can handle the request.
   Example: Opening a web page or sending an email.

**Main Uses of Intents:**

* Start an **Activity**
* Start or bind to a **Service**
* Send **Broadcast messages**
* Pass data between components using **Extras**

**Key Components of an Intent:**

* Action (what to do)
* Data (URI)
* Category
* Extras (key-value data)

**Example:**

```java
Intent i = new Intent(this, SecondActivity.class);
startActivity(i);
```

**Security Note:**

* Explicit intents are safer
* Implicit intents should be protected using permissions and intent filters

**One-line definition:**

> An Intent is a mechanism for communication between Android app components.



### **Use of Intents in Android App Hacking (Short Note – Educational & Security Perspective)**

In Android app security testing, **Intents are analyzed to find misconfigurations** that allow unauthorized access to app components. Attackers do not “hack with intents” directly, but **exploit insecure intent handling**.

**Main Security Uses in Hacking / Pentesting:**

1. **Component Exposure Testing**
   If an Activity, Service, or Receiver is marked as `exported=true`, it can be launched by other apps using an Intent.
   → This may allow access to **private screens or functions** without authentication.

2. **Intent Injection**
   Malicious apps can send crafted Intents with extra data (Extras) to:

* Bypass login screens
* Trigger hidden features
* Crash the app (DoS testing)

3. **Data Leakage Detection**
   Improperly protected Intents may expose:

* User data
* Internal app logic
* Debug activities

4. **Privilege Escalation Checks**
   If sensitive components do not require permissions, an attacker can call them via Intents and gain higher privileges.

5. **Reverse Engineering Support**
   Tools like **jadx** and **apktool** are used to inspect:

* Intent filters
* Exported components
* Weak security checks in intent handling

**Security Best Practices (Defense):**

* Use **explicit intents** for sensitive actions
* Set `exported=false` when not needed
* Validate all Intent data (Extras)
* Protect components with permissions

**One-line exam answer:**

> In Android hacking, Intents are analyzed to find exposed components, inject malicious data, and test for unauthorized access and information leakage.

This is studied in **ethical hacking and penetration testing** to improve app security, not to harm systems.
